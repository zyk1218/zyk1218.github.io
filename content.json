{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/02/28/hello-world/"},{"title":"first post text","text":"","link":"/2023/03/12/first-post-text/"},{"title":"","text":"Q：区的概念？为什么要有区？A：我们在操作一条记录的时候就是在操作数据页，虽然同一层的数据页通过双向链表链接，但是如果两个数据页的物理位置隔得很远的话，就变成了随机I/O，当我们在使用范围查询时，效率十分的低。为了可以使用顺序I/O，我们应该尽量使链表中相邻的页在物理上也相邻，为了达到这一目的，就有了区的概念区：连续的64个页组成一个区，没256个区被划分为1组 Q：段的概念A：如果我们把叶子结点和非叶子节点都放在同一个区的话，那么在进行范围查询的时候效率会大打折扣，因为非叶子节点并不会被范围扫，所以MySQL设计者提出了段的概念，一个索引分为两个段，叶子结点放在一个段，非叶子结点放在另外一个段。段以区为单位申请空间。这样带来的问题：因为段以区为单位申请空间，所以一个段至少1M，但是有的索引它并不会有这么多数据，为了防止这种浪费，设计者又提出了碎片区——碎片区中的页不专存储某一个段中的数据，它其中一部分页可以服务段A，一部分页可以服务段B。基于碎片区的概念，段申请资源的过程就变成了：当我们向表中插入数据时，先使用碎片区中的页，当我们使用到了32个碎片区的页后，就会申请一个完整的区用来存储我们该索引中的数据。 Q：区的分类 FREE：空闲的区 FREE_FRAG：有空余页面的碎片区 FULL_FRAG：无空余页面的碎片区 FSEG：附属于某个段的区 Q：区的管理方法我们有各种各样的区，为了方便管理，设计者提出了一个XDES Entry的结构，每一个区对应一个XDES Entry结构，这个结构如下： segment ID：区的ID List Node：用于将不同的区组织成一个双链表结构 State：区的状态，上述枚举的那四种 Page State Bitmap：该结构16个字节，共128个比特位，一个区有64个页，128个比特位用于标识64个页。","link":"/2023/05/27/long%20task%20-%20innodb%E4%B8%AD%E5%8C%BA%E3%80%81%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5/"}],"tags":[],"categories":[]}
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-innodb中区、段的概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/27/innodb%E4%B8%AD%E5%8C%BA%E3%80%81%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2023-05-27T14:13:44.581Z" itemprop="datePublished">2023-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Q：区的概念？为什么要有区？"><a href="#Q：区的概念？为什么要有区？" class="headerlink" title="Q：区的概念？为什么要有区？"></a>Q：区的概念？为什么要有区？</h3><p>A：我们在操作一条记录的时候就是在操作数据页，虽然同一层的数据页通过双向链表链接，但是如果两个数据页的物理位置隔得很远的话，就变成了随机I&#x2F;O，当我们在使用范围查询时，效率十分的低。<br>为了可以使用顺序I&#x2F;O，我们应该尽量使链表中相邻的页在物理上也相邻，为了达到这一目的，就有了区的概念<br>区：连续的64个页组成一个区，没256个区被划分为1组</p>
<h3 id="Q：段的概念"><a href="#Q：段的概念" class="headerlink" title="Q：段的概念"></a>Q：段的概念</h3><p>A：如果我们把叶子结点和非叶子节点都放在同一个区的话，那么在进行范围查询的时候效率会大打折扣，因为非叶子节点并不会被范围扫，所以MySQL设计者提出了段的概念，一个索引分为两个段，叶子结点放在一个段，非叶子结点放在另外一个段。段以区为单位申请空间。<br>这样带来的问题：因为段以区为单位申请空间，所以一个段至少1M，但是有的索引它并不会有这么多数据，为了防止这种浪费，设计者又提出了碎片区——碎片区中的页不专存储某一个段中的数据，它其中一部分页可以服务段A，一部分页可以服务段B。<br>基于碎片区的概念，段申请资源的过程就变成了：当我们向表中插入数据时，先使用碎片区中的页，当我们使用到了32个碎片区的页后，就会申请一个完整的区用来存储我们该索引中的数据。</p>
<h3 id="Q：区的分类"><a href="#Q：区的分类" class="headerlink" title="Q：区的分类"></a>Q：区的分类</h3><ul>
<li>FREE：空闲的区</li>
<li>FREE_FRAG：有空余页面的碎片区</li>
<li>FULL_FRAG：无空余页面的碎片区</li>
<li>FSEG：附属于某个段的区</li>
</ul>
<h3 id="Q：区的管理方法"><a href="#Q：区的管理方法" class="headerlink" title="Q：区的管理方法"></a>Q：区的管理方法</h3><p>我们有各种各样的区，为了方便管理，设计者提出了一个XDES Entry的结构，每一个区对应一个XDES Entry结构，这个结构如下：<img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1685183190477-02b379a8-bc4d-4ea9-a95d-4617e0404643.webp#averageHue=%23ccc369&clientId=u9d57a70e-7edb-4&from=paste&id=u8eb68050&originHeight=473&originWidth=1086&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u71213919-a395-4ffe-96e9-848f28e0b17&title="></p>
<ul>
<li>segment ID：区的ID</li>
<li>List Node：用于将不同的区组织成一个双链表结构</li>
<li>State：区的状态，上述枚举的那四种</li>
<li>Page State Bitmap：该结构16个字节，共128个比特位，一个区有64个页，128个比特位用于标识64个页。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/27/innodb%E4%B8%AD%E5%8C%BA%E3%80%81%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5/" data-id="cli62p4z00000a0wob5rx74jf" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-innodb-B-树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/21/innodb-B-%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2023-05-21T15:31:43.000Z" itemprop="datePublished">2023-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/21/innodb-B-%E6%A0%91/">innodb B+树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Q：为什么要有索引？"><a href="#Q：为什么要有索引？" class="headerlink" title="Q：为什么要有索引？"></a>Q：为什么要有索引？</h3><h4 id="当没有索引的时候如何查找数据？"><a href="#当没有索引的时候如何查找数据？" class="headerlink" title="当没有索引的时候如何查找数据？"></a>当没有索引的时候如何查找数据？</h4><p>如果查询条件是主键的话，我们可以遍历页目录，使用二分法定位到数据，但如果我们的查询条件不是主键时，那么我们的页目录就用不上了，我们只能遍历所有的页，当数据量十分庞大的时候，查询效率十分低下。</p>
<h3 id="Q：B-树的索引是怎么构建起来的？有什么依据吗？"><a href="#Q：B-树的索引是怎么构建起来的？有什么依据吗？" class="headerlink" title="Q：B+树的索引是怎么构建起来的？有什么依据吗？"></a>Q：B+树的索引是怎么构建起来的？有什么依据吗？</h3><h4 id="B-树长什么样？"><a href="#B-树长什么样？" class="headerlink" title="B+树长什么样？"></a>B+树长什么样？</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1684643956609-c3229eee-6604-4e3a-bf2d-c5a5345b690f.webp#averageHue=%23fafafa&clientId=ub80ad07d-5015-4&from=paste&height=259&id=u106499cb&originHeight=533&originWidth=1136&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=ue18ed32b-2a5d-4445-9dad-b7d998ad523&title=&width=552"><br>最后一层存放用户记录，称为<strong>叶子节点</strong>；<br>除最后一层外的节点用于存放目录项，均称为<strong>非叶子节点</strong><br>通常一颗B+树的层高不会超过4，原因见B+树的构建。</p>
<h4 id="B-树是如何构建起来的？"><a href="#B-树是如何构建起来的？" class="headerlink" title="B+树是如何构建起来的？"></a>B+树是如何构建起来的？</h4><p>首先，我们每一个数据页中都会记录该数据页中用户记录最大主键值和最小主键值，如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1684644377829-352501d6-31a6-4561-8c6c-8e44dfcfa193.webp#averageHue=%23fbf9f8&clientId=ub80ad07d-5015-4&from=paste&height=327&id=u937c3eb8&originHeight=517&originWidth=969&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u3732a373-61eb-48af-86b6-536f5927088&title=&width=613"><br>基于数据页中的最大记录和最小记录，我们可以针对数据页形成一个目录：<img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1684644431101-95f12f13-f341-4b5f-8d23-286611eff938.webp#averageHue=%23f9f3ef&clientId=ub80ad07d-5015-4&from=paste&height=335&id=u524efe8b&originHeight=573&originWidth=1098&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uae958545-9bf4-413f-b629-36473b9c9f2&title=&width=641"><br>上边的目录项就是数据页的目录，目录项中记录了对应数据页的最小值，而被目录项组织起来的数据页的主键值必须是依次递增了，也就是说目录项2中所有记录的主键值肯定是要大于目录项1中所有记录的主键值的。<br>之后，为了使数据页的目录更灵活，MySQL的设计者将这些目录信息存储到了“页”中，存储这些目录信息的页也被称为“<strong>索引页</strong>”，效果如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1684644615412-32ed3b18-6e7c-4833-85fc-d124a7ea6c71.webp#averageHue=%23e0dbc8&clientId=ub80ad07d-5015-4&from=paste&id=u81b2073b&originHeight=535&originWidth=1178&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uca9382fe-7512-4d18-8553-d7160babe80&title="><br>索引页中的记录有一个特点，就是它们头信息中的record_type为1，代表它们是目录项记录，而我们的普通记录对应的record_type是0。<br>当我们的数据页特别多的时候，我们需要用来记录页的目录项页就特别多了，那目录页多起来了后，我们为了提高检索效率，还得对目录项页整理目录，如下图：<img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1684644781592-c0206e12-e81d-4a24-a3d2-a90c91e0529c.webp#averageHue=%23dde0cc&clientId=ub80ad07d-5015-4&from=paste&id=u72070dbd&originHeight=579&originWidth=1080&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc2db5312-77c7-4aa7-93c5-f6f3407b65f&title="><br>那么到这里，我们的“树”已经呼之欲出了，这就是“B+”树的形成过程。<br>这里我们做一个简单计算，来说明为什么B+树不可能超过4层：<br>假设目录项页中可以记录的记录条数为1000，一个数据页中能记录的用户记录为100条，那4层B+树总共可以记录的信息有：1000<em>1000</em>1000*100&#x3D;1000亿条。我们正常一张表是不可能记录这么多数据的。</p>
<h3 id="Q：B-树有什么特点？"><a href="#Q：B-树有什么特点？" class="headerlink" title="Q：B+树有什么特点？"></a>Q：B+树有什么特点？</h3><h4 id="从构建过程中总结出来的特点："><a href="#从构建过程中总结出来的特点：" class="headerlink" title="从构建过程中总结出来的特点："></a>从构建过程中总结出来的特点：</h4><ol>
<li>定位一条数据，最多只需要关注4个页，分别是三个目录页，一个数据页</li>
<li>无论是数据页还是索引页，页和页之间在物理上都不是连续的，而是通过偏移量形成了一个双向链表</li>
</ol>
<h4 id="B-树本身的特点："><a href="#B-树本身的特点：" class="headerlink" title="B+树本身的特点："></a>B+树本身的特点：</h4><p>上边描述的B+树我们称之为聚簇索引，因为叶子节点上存储了完整的用户记录，索引即记录。</p>
<h3 id="Q：除聚簇索引外，还有别的索引吗？"><a href="#Q：除聚簇索引外，还有别的索引吗？" class="headerlink" title="Q：除聚簇索引外，还有别的索引吗？"></a>Q：除聚簇索引外，还有别的索引吗？</h3><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>我们上边描述的索引是基于主键生成的聚簇索引，我们在使用主键检索数据时，该索引效率很高，但是当我们使用非主键进行查找时，该索引就无法使用了，那么为了提高非主键查询时的查询效率，我们可以针对非主键字段建立索引，此类索引称为“二级索引”。<br><strong>二级索引的特点：</strong></p>
<ol>
<li>叶子节点不存储记录所有列的信息，只存储索引对应列的值和主键值</li>
<li>当需要获取其他字段值时，需要拿着主键回表查询</li>
</ol>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>针对多个列建立索引，假如我们对c1和c2列建立联合索引，我们会先根据c1进行排序，当c1值相同时，我们再对c2进行排序。效果图如下：<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1684646099890-88cd0a99-b2f8-4d89-a67c-7e101aab5079.webp#averageHue=%23e1e2d0&clientId=ub80ad07d-5015-4&from=paste&id=u25b15658&originHeight=617&originWidth=1153&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u90dcb8e7-7d14-44f9-9c70-6f36b11f7e7&title="></p>
<h3 id="Q：回表的代价"><a href="#Q：回表的代价" class="headerlink" title="Q：回表的代价"></a>Q：回表的代价</h3><h4 id="什么情况下会回表？"><a href="#什么情况下会回表？" class="headerlink" title="什么情况下会回表？"></a>什么情况下会回表？</h4><p>查询条件命中了二级索引，但是目标字段却不在二级索引中，此时就需要根据二级索引中记录的主键值回到聚簇索引中查询对应的记录值</p>
<h4 id="回表的影响"><a href="#回表的影响" class="headerlink" title="回表的影响"></a>回表的影响</h4><p>回表是随机I&#x2F;O，通常顺序I&#x2F;O的性能是要由于随机I&#x2F;O的，当我们回表次数过多的时候，innodb优化器会选择进行全表扫描</p>
<h4 id="如何避免回表？"><a href="#如何避免回表？" class="headerlink" title="如何避免回表？"></a>如何避免回表？</h4><ol>
<li>尽可能地限制查询到的数据</li>
<li>覆盖索引：我们查询的目标列最好是索引中的列</li>
</ol>
<h3 id="Q：如何使用B-树呢"><a href="#Q：如何使用B-树呢" class="headerlink" title="Q：如何使用B+树呢"></a>Q：如何使用B+树呢</h3><h4 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h4><p><strong>时间上的代价</strong>：每一次增删改的时候，我们都要维护对应的B+树<br><strong>空间上的代价</strong>：每建立一个索引，都会产生一颗B+树</p>
<h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><p><strong>全值匹配</strong>：查询条件和列值完全匹配<br><strong>最左匹配</strong>：假设我们针对列a，b，c建立了联合索引idx_a_b_c：</p>
<ol>
<li>那么当我们使用条件a，b，c进行查询的时候会先匹配a相等的记录，然后再匹配b，最后是c；</li>
<li>如果我们的查询条件是b，c，那就无法使用到该联合索引了；</li>
<li>如果查询条件是a，c，那么只可以使用到a列的索引</li>
</ol>
<p><strong>匹配列前缀</strong>：B+树中对于字符串进行了排序，所以我们使用部分前缀也可以快速地定位到数据，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column A from table where A like &quot;As%&quot;</span><br></pre></td></tr></table></figure>
<p>但是如果只给出中间或者末尾的某个字符，该索引就无法使用了，因为innodb并不会为某一列数据中间或末尾几个字符进行排序。<br><strong>范围查询</strong>：当使用范围查询时，只有联合索引做左边的列能够使用到<br><strong>精确匹配某一列并范围匹配另外一列</strong>：对于联合索引来说，如果可以精确匹配第一列，那么第二个条件可以范围匹配<br><strong>用于排序</strong>：通常当我们的sql中包含order by的时候，我们的做法是将数据load到内存中，在内存中对数据进行排序，当我们where条件名字的数据过多时，甚至还可能要使用到磁盘空间来完成排序，那么一但和磁盘沾边，那我们的查询效率就会很低了。但是如果我们的ordey by中使用索引字段来进行排序的话，我们就可以直接从索引里提取数据，再进行一次回表就可以的。<br><strong>不可以使用索引进行排序的情况：</strong></p>
<ol>
<li>ASC和DESC混用：因为我们的联合索引在创建的时候会根据A进行排序，A字段一样的记录再根据B字段进行排序，如果我们排序条件时A、B均升序，那么我们从索引最左边读10行就好，如果排序条件是A、B均降序，那么我们从索引最右边向左读10条就好，如果A增B减的话，我们需要先针对A增的情况挑选出10条数据，在根据B减的情况匹配出对应的十条，但是往往我们是无法精确匹配出10条B递减的数据的，于是我们又得重新在A增的情况下多拿出几条，这样会导致我们索引使用的效率特别低</li>
<li>多个用于排序的列不属于同一个索引</li>
<li>用于排序的列使用到了复杂表达式：当我们使用索引列进行排序时，必须保证该索引列是单独出现的，不能经过任何加工</li>
</ol>
<p><strong>用于分组</strong>：如果分组条件和我们索引字段一致的话，会提高分组sql语句的效率<br><strong>覆盖索引</strong>：我们查询的目标列最好是索引中的列</p>
<h3 id="Q：如何挑选索引"><a href="#Q：如何挑选索引" class="headerlink" title="Q：如何挑选索引"></a>Q：如何挑选索引</h3><ol>
<li>只为用于搜索、排序、分组的列创建索引</li>
<li>考虑列的区分度，越高越值得建立索引</li>
<li>索引列的类型尽可能地笑</li>
<li>索引字符串列的前缀</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/21/innodb-B-%E6%A0%91/" data-id="clhz0446q0002ngwohm0tfh4b" data-title="innodb B+树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-innodb行记录、数据组织形式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/21/innodb%E8%A1%8C%E8%AE%B0%E5%BD%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-05-21T15:31:03.000Z" itemprop="datePublished">2023-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/21/innodb%E8%A1%8C%E8%AE%B0%E5%BD%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/">innodb行记录、数据组织形式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="2023-05-13"><a href="#2023-05-13" class="headerlink" title="2023-05-13"></a>2023-05-13</h2><h3 id="1-innodb页"><a href="#1-innodb页" class="headerlink" title="1. innodb页"></a>1. innodb页</h3><h4 id="页是什么？为什么要有页的概念？"><a href="#页是什么？为什么要有页的概念？" class="headerlink" title="页是什么？为什么要有页的概念？"></a>页是什么？为什么要有页的概念？</h4><p>概念：页是innodb中磁盘和内存交互的基本单位，默认大小是16K。<br>意义：innodb是把数据存储在硬盘上的，但是在处理数据的时候却是在内存中的，如果在处理数据的时候把数据一条条数据的加载到内存或者写入到磁盘，那么就会导致innodb的读写效率十分的低，所以有了页的概念，可以使innodb一次性读出或写入多条数据</p>
<h3 id="2-innodb页的结构"><a href="#2-innodb页的结构" class="headerlink" title="2. innodb页的结构"></a>2. innodb页的结构</h3><h4 id="在讲页的结构之前，需要先了解innodb中数据的“行格式”"><a href="#在讲页的结构之前，需要先了解innodb中数据的“行格式”" class="headerlink" title="在讲页的结构之前，需要先了解innodb中数据的“行格式”"></a>在讲页的结构之前，需要先了解innodb中数据的“行格式”</h4><p>数据是以记录的形式存储在磁盘中的，那么数据是如何组织起来进行存放的呢？“行格式”就是规定了数据如何存放的一个协议，所以“行格式”也称为“记录格式”</p>
<ul>
<li>行格式的种类： <ul>
<li>compact<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e8fafc21aa~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp#id=VCu7e&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1683988033454-bb8be8e5-662d-4a59-a379-4ca750184bfb.webp#averageHue=%23f7ebe3&clientId=ufe91ca8b-3712-4&from=paste&id=u9b1d8b97&originHeight=250&originWidth=783&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u69c9a56d-974f-47b7-9990-38003b063ee&title="><br>从图来看，行格式分为两部分，一部分用于记录额外信息，一部分用于记录真实数据。</li>
<li>redundant<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e99a69ba3d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp#id=HHzFP&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1683988046339-97b714bb-322c-474e-bd52-2a3bd78ad2e0.webp#averageHue=%23f6e9e0&clientId=ufe91ca8b-3712-4&from=paste&id=u94dd4dd6&originHeight=251&originWidth=618&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u6136e7ba-0f4d-4590-b6a7-4c16f29317b&title="></li>
<li>dynamic</li>
<li>compressd</li>
</ul>
</li>
<li>compact：<br><strong>变长字段的记录</strong>：部分字段的长度不固定，为了可以让innodb更好地处理此类字段，所以记录了该类字段的一些信息。<br>这些信息的记录规则是：将每一列变长字段的长度按照逆序存放。<br><strong>NULL值记录</strong>：当某个字段的值是NULL时，如果我们还将该字段记录在真实数据记录中，这样无疑会浪费空间，所以在compact中，将NULL值进行记录<br><strong>记录头信息</strong>：记录头信息大小为5byte，共40个二进制位，共记录了_删除标记_、<em>B+树中每层非叶子结点最小记录标识_、_当前记录拥有的记录数_、_当前记录在记录堆中的信息_、_记录类型_、_下一条记录的相对位置</em><br><strong>记录的真实数据</strong>：除了我们存储的字段外，innodb会给每条记录添加三列隐藏列——“row_id”、“transaction_id”、“roll_pointer”，分别代表“行记录ID”、“事务ID”、“回滚ID”。其中“row_id”是当用户没用定义主键且没有唯一键时用来充当“主键”的。 </li>
<li>redundant:<br><strong>字段长度偏移列表</strong>：相比于compact格式，redundant格式在额外信息中记录的并不是变长字段列表，而是字段长度偏移量。也正是因为redundant没有记录变长字段的列表,所以它是将所有列的长度信息都按逆序的方式存储下来了。<br><strong>记录头信息</strong>：相比于compact格式，redundant格式的记录头信息的长度是6字节，48个二进制位，记录了_删除标记_、_B+树中每层非叶子结点最小记录标识_、_当前记录拥有的记录数_、_当前记录在记录堆中的信息_、_该记录中列的数量_、_标记长度偏移列表中每个列对应的偏移量是用1字节还是2字节表示的_、_下一条记录的绝对位置_。<br>与compatct格式不同的是，多了“记录中列数量”、“偏移量的长度标识”，compact用相对位置标识下一条记录，而redundant用绝对位置标识。<br><strong>与compact的不同之处</strong>： <ul>
<li>多了“记录中列数量”、“偏移量的长度标识”</li>
<li>compact用相对位置标识下一条记录，而redundant用绝对位置标识。</li>
<li>redundant没有“记录类型”</li>
<li>redundant中使用字段偏移量中的第一个比特位标识该列是否是NULL，而compact是用NULL列表来记录</li>
</ul>
</li>
<li>行溢出：<br>数据页的基本大小为16k，但是有可能一条记录的大小就超过了16k，此类情况成为行溢出。 </li>
<li>dynamic和compressd:<br>这两种行格式与compact很像，区别是处理行溢出的方式不同，dynamic是将所有的字节存储到另外一个页里，compressd是在dynamic的基础上应用了压缩算法。 </li>
<li>行记录中的字段含义： <ul>
<li>deleta_mask(删除标识)：当我们删除某一条记录的时候，innodb只是将该记录对应的delete_mask置为了1，而不是立马从磁盘上删除掉这条数据，原因是因为删除数据后需要重新排列，十分消耗性能。这些被删除的记录会组成一个垃圾链表，当有新数据要插入时，可以覆盖这些记录。</li>
<li>heap_no(当前记录在该页中的位置)：位置都是从2开始的，因为0、1被两条虚拟记录占了，这两条虚拟记录分别是最大记录（supremum）和最小记录（infinum）</li>
<li>record_type(记录标识)：共四种记录类型，0-普通记录，1-B+树非叶子结点记录，2-最小记录，3-最大记录。</li>
</ul>
</li>
</ul>
<h4 id="innodb的页结构"><a href="#innodb的页结构" class="headerlink" title="innodb的页结构"></a>innodb的页结构</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/29572773/1683987973550-662e738c-6bdc-40be-a50b-5cf33e606473.webp#averageHue=%23d1a145&clientId=ufe91ca8b-3712-4&from=paste&id=u4d9be615&originHeight=1072&originWidth=934&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uca58be8c-ef5c-444a-8d58-4ba98f71eba&title="></p>
<ul>
<li>file header：文件头，占38byte，存储页的通用信息</li>
<li>page header：页头，占56byte，存储页的专有信息</li>
<li>infinum + supremum：占26byte，本页中数据的最小记录和最大记录</li>
<li>user records：大小不定，用户存储的记录</li>
<li>free space：大小不定，空余空间</li>
<li>page directory：大小不定，页面中某些记录的相对位置</li>
<li>file trailer：占8byte，校验页的完整性</li>
</ul>
<p><strong>page directpry</strong>页目录<br>页目录类似书本的目录，用于帮innodb快速定位目标数据，它的形成如下：</p>
<ol>
<li>将数据记录进行分组</li>
<li>每组的最后一条记录的记录头信息中的n_owner字段记录了改组中拥有几条记录</li>
<li>将每组的最后一条记录的偏移量提取出来放在页尾，也就是page directory中。</li>
</ol>
<p><strong>page header</strong>页的头部<br>页头用于存储本页专有的一些信息，如下：</p>
<ul>
<li>PAGE_N_DIR_SLOTS：页中的槽数量</li>
<li>PAGE_HEAP_TOP：还未使用的空间最小地址，也就是说从该地址之后就是Free Space</li>
<li>PAGE_N_HEAP：本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</li>
<li>PAGE_FREE：第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</li>
<li>PAGE_GARBAGE：已删除记录占用的字节数</li>
<li>PAGE_LAST_INSERT：最后插入记录的位置</li>
<li>PAGE_DIRECTION：记录插入的方向</li>
<li>PAGE_N_DIRECTION：一个方向连续插入的记录数量</li>
<li>PAGE_N_RECS：	该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</li>
<li>PAGE_MAX_TRX_ID：修改当前页的最大事务ID，该值仅在二级索引中定义</li>
<li>PAGE_LEVEL：当前页在B+树中所处的层级</li>
<li>PAGE_INDEX_ID：索引ID，表示当前页属于哪个索引</li>
<li>PAGE_BTR_SEG_LEAF：B+树叶子段的头部信息，仅在B+树的Root页定义</li>
<li>PAGE_BTR_SEG_TOP：B+树非叶子段的头部信息，仅在B+树的Root页定义</li>
</ul>
<p><strong>File Header文件头部</strong><br>所有的页通用的结构，存储信息如下：</p>
<ul>
<li>FIL_PAGE_SPACE_OR_CHKSUM：页的校验和（checksum值），把一个较长的字符串转换为较短的字符串，在比较这个字符串之前可以先比较校验和，如果校验和都不一样的话，那么参与比较的俩字符串肯定不一样</li>
<li>FIL_PAGE_OFFSET：页号</li>
<li>FIL_PAGE_PREV：上一个页的页号</li>
<li>FIL_PAGE_NEXT：下一个页的页号</li>
<li>FIL_PAGE_LSN：页面被最后修改时对应的日志序列位置</li>
<li>FIL_PAGE_TYPE：该页的类型</li>
<li>FIL_PAGE_FILE_FLUSH_LSN：仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</li>
<li>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID：页属于哪个表空间</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/21/innodb%E8%A1%8C%E8%AE%B0%E5%BD%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/" data-id="clhz0446o0001ngwo3p28chq0" data-title="innodb行记录、数据组织形式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LT启动" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/21/LT%E5%90%AF%E5%8A%A8/" class="article-date">
  <time class="dt-published" datetime="2023-05-21T15:20:14.000Z" itemprop="datePublished">2023-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/21/LT%E5%90%AF%E5%8A%A8/">LT启动</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="交流时间：每周日15：00点"><a href="#交流时间：每周日15：00点" class="headerlink" title="交流时间：每周日15：00点"></a>交流时间：每周日15：00点</h3><h3 id="固定分享内容："><a href="#固定分享内容：" class="headerlink" title="固定分享内容："></a>固定分享内容：</h3><ul>
<li>思考：需求、培训等工作中各种各样的思考，有趣的需求，受益的感悟···</li>
<li>故障分享：自己遇到的线上线下问题、别的团队的线上事故等，是怎么发生的，是怎么解决的，有什么可以借鉴的经验</li>
<li>业务理解：为对方讲解自己负责系统的功能、边界，自己对该系统的技术规划、业务的理解，表达清楚所以然</li>
<li>新技术：偶然间读到的一篇博文、公众号推送等，总结出概要，讲清楚重点</li>
</ul>
<h3 id="指定分享内容："><a href="#指定分享内容：" class="headerlink" title="指定分享内容："></a>指定分享内容：</h3><ul>
<li>innodb的数据组织、存储格式</li>
</ul>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo:"></a>todo:</h3><ol>
<li>五月底完善各自的博客，后续的分享基于博客</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/21/LT%E5%90%AF%E5%8A%A8/" data-id="clhz0446l0000ngwo8c3v6dg0" data-title="LT启动" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/27/innodb%E4%B8%AD%E5%8C%BA%E3%80%81%E6%AE%B5%E7%9A%84%E6%A6%82%E5%BF%B5/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/21/innodb-B-%E6%A0%91/">innodb B+树</a>
          </li>
        
          <li>
            <a href="/2023/05/21/innodb%E8%A1%8C%E8%AE%B0%E5%BD%95%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/">innodb行记录、数据组织形式</a>
          </li>
        
          <li>
            <a href="/2023/05/21/LT%E5%90%AF%E5%8A%A8/">LT启动</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>